<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Global Multiplayer Pong</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #1a202c; /* Dark background */
            font-family: 'Press Start 2P', cursive;
            color: #48bb78; /* Green for retro feel */
        }
        #game-container {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        canvas {
            background-color: #000;
            border: 4px solid #48bb78;
            box-shadow: 0 0 20px rgba(72, 187, 120, 0.7);
            border-radius: 8px;
            display: block;
        }
        .btn-retro {
            background-color: #48bb78;
            color: #1a202c;
            border: 3px solid #1a202c;
            text-shadow: 1px 1px 0 #fff;
            box-shadow: 4px 4px 0 #1a202c;
            transition: all 0.1s;
        }
        .btn-retro:hover {
            box-shadow: 2px 2px 0 #1a202c;
            transform: translate(2px, 2px);
        }
        .text-retro {
            color: #48bb78;
            text-shadow: 1px 1px 0 #1a202c;
        }
        .leaderboard-table th, .leaderboard-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px dashed #48bb78;
        }
        .error-message {
            color: #f56565; /* Red */
            font-size: 1rem;
            text-align: center;
            padding: 10px;
            border: 2px solid #f56565;
            border-radius: 4px;
        }
    </style>
</head>
<body class="p-4 flex flex-col items-center min-h-screen">
    <div id="game-container" class="space-y-6">
        <h1 class="text-3xl text-center text-retro mb-6">GLOBAL PONG MATCH</h1>

        <!-- Status and Role Info -->
        <div class="flex flex-col md:flex-row justify-between items-center text-sm mb-4 space-y-2 md:space-y-0 text-retro">
            <span id="user-id">User ID: Loading...</span>
            <span id="player-role" class="text-xl font-bold">Role: Spectator</span>
            <span id="current-room-id">Match: Global</span>
        </div>

        <!-- Canvas for the Pong Game -->
        <canvas id="pong-canvas" width="800" height="400"></canvas>

        <!-- Controls and Status -->
        <div id="game-status" class="text-center text-lg text-red-500 my-4">Initializing...</div>
        <div id="game-controls" class="flex flex-wrap justify-center gap-4">
            <button id="join-match-btn" class="btn-retro px-6 py-3 rounded-lg text-lg w-full md:w-auto">Claim Player Spot</button>
            <button id="leave-match-btn" class="btn-retro px-6 py-3 rounded-lg text-lg w-full md:w-auto" disabled>Relinquish Spot</button>
        </div>
        
        <p class="text-sm text-center text-retro opacity-70 mt-2">P1 controls physics. Use W/S or Arrow Keys to move your paddle.</p>

        <!-- Leaderboard Section -->
        <div class="mt-8">
            <h2 class="text-xl text-retro mb-4">LEADERBOARD</h2>
            <table class="leaderboard-table w-full text-sm">
                <thead>
                    <tr>
                        <th class="text-retro">Rank</th>
                        <th class="text-retro">User ID</th>
                        <th class="text-retro">Score (W-L)</th>
                    </tr>
                </thead>
                <tbody id="leaderboard-body" class="text-white">
                    <tr><td colspan="3" class="text-center">Loading leaderboard...</td></tr>
                </tbody>
            </table>
        </div>
    </div>
    
    <!-- Image of how the Global Match Architecture works -->
    <div class="text-center text-retro pt-10">
        <h3 class="text-xl mb-4">Global Match Architecture</h3>
        <p class="text-sm mb-4"></p>
    </div>

    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, setPersistence, browserSessionPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, doc, setDoc, updateDoc, onSnapshot, 
            collection, query, addDoc, serverTimestamp, setLogLevel, runTransaction 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- GLOBAL VARIABLES PROVIDED BY THE ENVIRONMENT ---
        const statusEl = document.getElementById('game-status');
        const GLOBAL_MATCH_DOC_ID = 'match_state';

        // --- HARDCODED FIREBASE CONFIGURATION (Provided by user) ---
        const firebaseConfig = {
            apiKey: "AIzaSyDGTc7KZXnOpT2OihaPU-UAt4GPjIZe1Ks",
            authDomain: "pong-4c2e4.firebaseapp.com",
            projectId: "pong-4c2e4",
            storageBucket: "pong-4c2e4.firebasestorage.app",
            messagingSenderId: "999682292766",
            appId: "1:999682292766:web:ba8aa3a5d81a8ea840420f",
            measurementId: "G-QN6XQG2NRL"
        };
        
        // Use the provided appId directly, or fall back to environment variable if defined.
        const appId = typeof __app_id !== 'undefined' ? __app_id : firebaseConfig.appId;
        const initialToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : '';

        // --- CRITICAL CONFIG CHECK ---
        if (!firebaseConfig || !firebaseConfig.projectId) {
            statusEl.textContent = "FATAL ERROR: Firebase Configuration is incomplete. Cannot initialize DB.";
            statusEl.classList.add('error-message');
            console.error("CRITICAL ERROR: Firebase configuration is missing or invalid. Execution halted.");
            throw new Error("Missing Firebase projectId");
        }
        
        // --- FIREBASE INITIALIZATION AND AUTHENTICATION ---
        let app, db, auth;
        let userId = '';
        let isAuthReady = false; // Flag to gate Firestore operations

        app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        auth = getAuth(app);
        setLogLevel('debug');

        // State variables for the game
        let isPlayer1 = false;
        let isPlayer2 = false;
        let isSpectator = true;
        let isGameRunning = false;
        let unsubscribeMatch = null;
        let unsubscribeLeaderboard = null;

        // --- PONG GAME STATE ---
        const canvas = document.getElementById('pong-canvas');
        const ctx = canvas.getContext('2d');

        const PADDLE_HEIGHT = 80;
        const PADDLE_WIDTH = 10;
        const BALL_RADIUS = 6;
        const PADDLE_SPEED = 5;
        const WIN_SCORE = 10;
        
        // Local state, synchronized with Firestore
        let gameState = {
            player1Id: null,
            player2Id: null,
            paddle1Y: canvas.height / 2 - PADDLE_HEIGHT / 2,
            paddle2Y: canvas.height / 2 - PADDLE_HEIGHT / 2,
            ballX: canvas.width / 2,
            ballY: canvas.height / 2,
            ballDx: 4,
            ballDy: 4,
            score1: 0,
            score2: 0,
            status: 'WaitingForPlayers', // 'WaitingForPlayers', 'Playing', 'GameOver'
            lastUpdateTime: Date.now(),
            lastSyncTime: Date.now(),
        };

        // --- UTILITY & FIREBASE PATH FUNCTIONS ---

        function getPublicCollectionPath(collectionName) {
            return `artifacts/${appId}/public/data/${collectionName}`;
        }

        function getMatchDocRef() {
            return doc(db, getPublicCollectionPath('global_pong'), GLOBAL_MATCH_DOC_ID);
        }

        /**
         * Resets the local ball position and direction for serving.
         */
        function resetBall() {
            gameState.ballX = canvas.width / 2;
            gameState.ballY = canvas.height / 2;
            gameState.ballDx = (Math.random() > 0.5 ? 4 : -4);
            gameState.ballDy = (Math.random() * 8 - 4);
        }
        
        /**
         * Initializes or resets the global match state document in Firestore.
         */
        async function initializeMatchState(docRef) {
            const initialBallDx = (Math.random() > 0.5 ? 4 : -4);
            const initialBallDy = (Math.random() * 8 - 4);

            await setDoc(docRef, {
                player1Id: null,
                player2Id: null,
                paddle1Y: canvas.height / 2 - PADDLE_HEIGHT / 2,
                paddle2Y: canvas.height / 2 - PADDLE_HEIGHT / 2,
                ballX: canvas.width / 2,
                ballY: canvas.height / 2,
                ballDx: initialBallDx, 
                ballDy: initialBallDy, 
                score1: 0,
                score2: 0,
                status: 'WaitingForPlayers',
                lastUpdateTime: serverTimestamp(),
            });
            console.log("Global match state initialized.");
        }

        // --- AUTHENTICATION (FIXED FLOW) ---

        /**
         * Handles the full sign-in process and sets up the onAuthStateChanged listener.
         */
        async function authenticateAndSetup() {
             try {
                // 1. Attempt persistent sign-in first
                await setPersistence(auth, browserSessionPersistence);
                
                let authSuccessful = false;

                // 1a. Try to sign in with custom token if available
                if (initialToken) {
                    try {
                        await signInWithCustomToken(auth, initialToken);
                        authSuccessful = true;
                    } catch (tokenError) {
                        // If custom token fails (e.g., auth/custom-token-mismatch), log and proceed to anonymous sign-in
                        console.warn("Custom token sign-in failed. Falling back to anonymous sign-in:", tokenError);
                    }
                }

                // 1b. If custom auth wasn't attempted or failed, sign in anonymously
                if (!authSuccessful) {
                    await signInAnonymously(auth);
                }
                
                // 2. Set up the definitive listener
                onAuthStateChanged(auth, (user) => {
                    if (user && user.uid) {
                        userId = user.uid;
                        isAuthReady = true;
                        document.getElementById('user-id').textContent = `User ID: ${userId}`;
                        statusEl.textContent = "Authentication complete. Starting game subscription...";
                        
                        // CRITICAL FIX: Only subscribe when auth is confirmed and ready.
                        subscribeToMatch();
                        fetchLeaderboard();
                        
                    } else {
                        // User signed out or failed auth initially
                        isAuthReady = false;
                        userId = '';
                        document.getElementById('user-id').textContent = `User ID: Not Signed In`;
                        statusEl.textContent = "Authentication failed. Cannot connect to match.";

                        // Clean up listeners if they exist
                        if (unsubscribeMatch) unsubscribeMatch();
                        if (unsubscribeLeaderboard) unsubscribeLeaderboard();
                    }
                });
            } catch (error) {
                // This catches if the anonymous sign-in failed
                console.error("Authentication initialization failed:", error);
                statusEl.textContent = `Error: Authentication failed (${error.code}). Cannot play.`;
                statusEl.classList.add('error-message');
                isAuthReady = false;
            }
        }


        // --- PLAYER SPOT MANAGEMENT ---

        /**
         * Attempts to claim an open player spot (P1 or P2) using a Firestore Transaction.
         */
        async function claimPlayerSpot() {
            if (!isAuthReady) {
                alertUser("Please wait for authentication to complete.");
                return;
            }
            const docRef = getMatchDocRef();

            try {
                const claimedRole = await runTransaction(db, async (transaction) => {
                    const matchDoc = await transaction.get(docRef);
                    let updateData = {};
                    let claimedRole = null;

                    if (!matchDoc.exists()) {
                        // Document doesn't exist, initialize it and claim P1
                        transaction.set(docRef, {
                            player1Id: userId,
                            player2Id: null,
                            paddle1Y: canvas.height / 2 - PADDLE_HEIGHT / 2,
                            paddle2Y: canvas.height / 2 - PADDLE_HEIGHT / 2,
                            ballX: canvas.width / 2,
                            ballY: canvas.height / 2,
                            ballDx: (Math.random() > 0.5 ? 4 : -4),
                            ballDy: (Math.random() * 8 - 4),
                            score1: 0,
                            score2: 0,
                            status: 'WaitingForPlayers',
                            lastUpdateTime: serverTimestamp(),
                        });
                        claimedRole = 'Player 1';
                    } else {
                        const data = matchDoc.data();

                        // Check if already a player
                        if (data.player1Id === userId || data.player2Id === userId) {
                            throw "Already a player in this match.";
                        }

                        // Try to claim P1 spot
                        if (!data.player1Id) {
                            updateData.player1Id = userId;
                            claimedRole = 'Player 1';
                        } 
                        // Try to claim P2 spot
                        else if (!data.player2Id) {
                            updateData.player2Id = userId;
                            claimedRole = 'Player 2';
                        } else {
                            throw "No open player spots available. Spectating.";
                        }
                        
                        // If one spot was claimed, check if both are now filled
                        if (claimedRole && (data.player1Id || claimedRole === 'Player 1') && (data.player2Id || claimedRole === 'Player 2')) {
                            updateData.status = 'Playing';
                            // Reset scores and ball when a new match begins
                            updateData.score1 = 0;
                            updateData.score2 = 0;
                            resetBall(); // Recalculate ball physics locally
                            updateData.ballX = gameState.ballX;
                            updateData.ballY = gameState.ballY;
                            updateData.ballDx = gameState.ballDx;
                            updateData.ballDy = gameState.ballDy;
                        }

                        if (Object.keys(updateData).length > 0) {
                             transaction.update(docRef, updateData);
                        } else {
                             // This path is usually hit by the 'No open spots' exception
                        }
                    }
                    return claimedRole || 'Spectator';
                });

                // Transaction successful 
                alertUser(`Successfully joined the match. Role: ${claimedRole}`);

            } catch (e) {
                if (typeof e === 'string' && e.includes("No open player spots")) {
                    alertUser(e); // Spectating message
                } else if (e !== "Already a player in this match.") {
                    console.error("Transaction failed:", e);
                    alertUser("Failed to claim spot. Try again.");
                }
            }
        }

        /**
         * Relinquishes the currently held player spot (P1 or P2).
         * This function handles MANUAL relinquishment via the button.
         */
        async function relinquishPlayerSpot() {
            if (!isAuthReady || isSpectator) return;
            const docRef = getMatchDocRef();
            let updateData = {};
            let roleToClear = null;

            if (isPlayer1) {
                updateData.player1Id = null;
                updateData.paddle1Y = canvas.height / 2 - PADDLE_HEIGHT / 2;
                roleToClear = 'Player 1';
            } else if (isPlayer2) {
                updateData.player2Id = null;
                updateData.paddle2Y = canvas.height / 2 - PADDLE_HEIGHT / 2;
                roleToClear = 'Player 2';
            } else {
                return; 
            }

            // If a player leaves, status should go back to WaitingForPlayers
            updateData.status = 'WaitingForPlayers';

            try {
                await updateDoc(docRef, updateData);
                alertUser(`${roleToClear} spot relinquished. You are now a Spectator.`);
            } catch (error) {
                console.error("Error relinquishing spot:", error);
                alertUser("Failed to relinquish spot. Check console.");
            }
        }
        
        // --- MATCH SUBSCRIPTION AND STATE HANDLING ---

        function subscribeToMatch() {
            if (unsubscribeMatch) unsubscribeMatch();
            if (!isAuthReady || !userId) {
                console.warn("Auth not ready, skipping match subscription.");
                return; // Safety guard ensures no subscription attempt while state is unstable
            }

            const docRef = getMatchDocRef();

            unsubscribeMatch = onSnapshot(docRef, (docSnapshot) => {
                if (docSnapshot.exists()) {
                    handleMatchUpdate(docSnapshot.data());
                } else {
                    // Document was deleted. Re-initialize state.
                    handleMatchDeletion();
                }
            }, (error) => {
                // This will catch the permissions error if the user isn't fully ready
                console.error("Error subscribing to global match:", error);
                alertUser("Lost connection to the global match or permissions error.");
            });
            console.log("Match listener attached.");
        }

        function handleMatchUpdate(matchData) {
            
            // 1. Determine User Role
            isPlayer1 = matchData.player1Id === userId;
            isPlayer2 = matchData.player2Id === userId;
            isSpectator = !isPlayer1 && !isPlayer2;

            let roleText = 'Spectator';
            if (isPlayer1) roleText = 'Player 1 (Host)';
            else if (isPlayer2) roleText = 'Player 2';
            
            document.getElementById('player-role').textContent = `Role: ${roleText}`;
            
            // Update UI buttons based on role
            document.getElementById('join-match-btn').disabled = isPlayer1 || isPlayer2 || !isAuthReady || (matchData.player1Id && matchData.player2Id);
            document.getElementById('leave-match-btn').disabled = isSpectator || !isAuthReady;


            // 2. Update Local Game State
            Object.assign(gameState, matchData); // Copy all remote data to local state
            
            // 3. Update Game Status
            let statusMessage = '';
            if (matchData.status === 'Playing') {
                isGameRunning = true;
                statusMessage = `Playing: ${matchData.score1} - ${matchData.score2}`;
            } else if (matchData.status === 'WaitingForPlayers') {
                isGameRunning = false;
                const p1Status = matchData.player1Id ? `${matchData.player1Id.substring(0, 8)}...` : 'Open';
                const p2Status = matchData.player2Id ? `${matchData.player2Id.substring(0, 8)}...` : 'Open';
                statusMessage = `Waiting for Players: P1: ${p1Status} | P2: ${p2Status}`;
            } else if (matchData.status === 'GameOver') {
                isGameRunning = false;
                statusMessage = `Game Over. Final Score: ${matchData.score1} - ${matchData.score2}. Waiting to restart.`;
            }
            
            statusEl.textContent = statusMessage;
            statusEl.classList.remove('text-red-500', 'text-yellow-500', 'text-green-500');
            statusEl.classList.add(isGameRunning ? 'text-yellow-500' : 'text-green-500');
        }

        function handleMatchDeletion() {
            alertUser('The global match state document was unexpectedly deleted. Re-initializing...');
            initializeMatchState(getMatchDocRef());
        }

        /**
         * Sends the local game state (ball and scores) to Firestore. Only Player 1 (host) executes physics.
         */
        function sendGameUpdate() {
            if (!isPlayer1 || !isGameRunning) return;

            const updateData = {
                paddle1Y: gameState.paddle1Y,
                paddle2Y: gameState.paddle2Y,
                ballX: gameState.ballX,
                ballY: gameState.ballY,
                ballDx: gameState.ballDx,
                ballDy: gameState.ballDy,
                score1: gameState.score1,
                score2: gameState.score2,
                status: 'Playing',
                lastUpdateTime: serverTimestamp(),
            };
            // Use retry logic (omitted here for brevity, covered by Firestore SDK)
            updateDoc(getMatchDocRef(), updateData).catch(e => console.error("Error syncing game state:", e));
        }

        /**
         * Sends only the local paddle position to Firestore. (P2 sends separately).
         */
        function sendPaddleUpdate() {
            if (!isGameRunning) return;

            if (isPlayer2) {
                // P2 only updates paddle2Y
                updateDoc(getMatchDocRef(), { paddle2Y: gameState.paddle2Y }).catch(e => console.error("Error syncing P2 paddle:", e));
            }
            // P1's paddle is included in sendGameUpdate()
        }
        
        /**
         * Checks if a player has won and updates the score/status.
         * Runs only on P1 (physics host).
         */
        function checkWinCondition() {
            if (!isPlayer1) return;

            if (gameState.score1 >= WIN_SCORE || gameState.score2 >= WIN_SCORE) {
                let winnerId = gameState.score1 >= WIN_SCORE ? gameState.player1Id : gameState.player2Id;
                let loserId = gameState.score1 >= WIN_SCORE ? gameState.player2Id : gameState.player1Id;
                let winnerScore = Math.max(gameState.score1, gameState.score2);
                let loserScore = Math.min(gameState.score1, gameState.score2);

                recordScore(winnerId, loserId, winnerScore, loserScore);

                // --- MODIFICATION: Auto-relinquish spot by clearing player IDs ---
                const docRef = getMatchDocRef();
                updateDoc(docRef, {
                    player1Id: null, // AUTOMATICALLY RELEASE P1 SPOT
                    player2Id: null, // AUTOMATICALLY RELEASE P2 SPOT
                    score1: 0,
                    score2: 0,
                    ballX: canvas.width / 2,
                    ballY: canvas.height / 2,
                    status: 'WaitingForPlayers', // Back to waiting state
                }).catch(e => console.error("Error resetting match state:", e));
            }
        }

        // --- GAME PHYSICS & RENDERING ---

        function updateLocalGame() {
            if (!isPlayer1 || !isGameRunning) return;

            // 1. Ball movement
            gameState.ballX += gameState.ballDx;
            gameState.ballY += gameState.ballDy;

            // 2. Ball collision with top/bottom walls
            if (gameState.ballY - BALL_RADIUS < 0 || gameState.ballY + BALL_RADIUS > canvas.height) {
                gameState.ballDy *= -1;
            }

            // 3. Ball collision with paddles
            const paddle1Area = gameState.ballX - BALL_RADIUS < PADDLE_WIDTH;
            const paddle2Area = gameState.ballX + BALL_RADIUS > canvas.width - PADDLE_WIDTH;

            // Paddle 1 (Left) collision
            if (paddle1Area && gameState.ballY > gameState.paddle1Y && gameState.ballY < gameState.paddle1Y + PADDLE_HEIGHT) {
                gameState.ballDx *= -1.05; // Increase speed slightly
            }
            
            // Paddle 2 (Right) collision
            if (paddle2Area && gameState.ballY > gameState.paddle2Y && gameState.ballY < gameState.paddle2Y + PADDLE_HEIGHT) {
                gameState.ballDx *= -1.05; // Increase speed slightly
            }

            // 4. Scoring
            let scoreUpdate = false;
            if (gameState.ballX < 0) {
                gameState.score2++;
                resetBall();
                scoreUpdate = true;
            } else if (gameState.ballX > canvas.width) {
                gameState.score1++;
                resetBall();
                scoreUpdate = true;
            }

            // 5. Check win condition after scoring
            if (scoreUpdate) {
                checkWinCondition();
            }
        }

        function renderGame() {
            // Background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Center Line (Dashed)
            ctx.strokeStyle = '#48bb78';
            ctx.beginPath();
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 10]);
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);

            // Paddles
            ctx.fillStyle = '#fff';
            // Highlight current user's paddle
            const p1Color = isPlayer1 ? '#facc15' : '#fff'; // Yellow highlight for user
            const p2Color = isPlayer2 ? '#facc15' : '#fff';
            
            ctx.fillStyle = p1Color;
            ctx.fillRect(0, gameState.paddle1Y, PADDLE_WIDTH, PADDLE_HEIGHT);
            
            ctx.fillStyle = p2Color;
            ctx.fillRect(canvas.width - PADDLE_WIDTH, gameState.paddle2Y, PADDLE_WIDTH, PADDLE_HEIGHT);

            // Ball
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(gameState.ballX, gameState.ballY, BALL_RADIUS, 0, Math.PI * 2);
            ctx.fill();

            // Scores
            ctx.font = '30px "Press Start 2P"';
            ctx.fillStyle = '#48bb78';
            ctx.textAlign = 'center';
            ctx.fillText(gameState.score1, canvas.width / 4, 40);
            ctx.fillText(gameState.score2, canvas.width * 3 / 4, 40);
        }

        // --- GAME LOOP ---
        function gameLoop() {
            requestAnimationFrame(gameLoop);
            
            // Only P1 runs the physics update
            if (isPlayer1 && isGameRunning) {
                updateLocalGame(); 
            }
            
            // P1 syncs the state regularly (approx 10 times a second)
            if (isPlayer1 && isGameRunning && Date.now() - gameState.lastSyncTime > 100) { 
                sendGameUpdate();
                gameState.lastSyncTime = Date.now();
            }
            
            // All users render the latest state
            renderGame();
        }


        // --- INPUT HANDLING ---
        let keys = {};
        document.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
        document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

        function handleInput() {
            // Only players can move
            if (!isGameRunning || isSpectator) return;

            const playerPaddleY = isPlayer1 ? 'paddle1Y' : 'paddle2Y';

            let moved = false;
            // Check for both Arrow Keys and W/S
            if (keys['arrowup'] || keys['w']) {
                gameState[playerPaddleY] -= PADDLE_SPEED * 2;
                moved = true;
            }
            if (keys['arrowdown'] || keys['s']) {
                gameState[playerPaddleY] += PADDLE_SPEED * 2;
                moved = true;
            }

            if (moved) {
                // Ensure paddle stays on screen before sending update
                gameState[playerPaddleY] = Math.min(Math.max(0, gameState[playerPaddleY]), canvas.height - PADDLE_HEIGHT);
                // P2 must send their paddle update immediately
                if (isPlayer2) {
                    sendPaddleUpdate();
                }
                // P1's paddle position is sent via the regular sendGameUpdate loop
            }
        }

        // --- LEADERBOARD & SCORE RECORDING ---
        async function recordScore(winnerId, loserId, winnerScore, loserScore) {
            if (!db || !isAuthReady) return;
            try {
                // Store in public collection for the leaderboard
                await addDoc(collection(db, getPublicCollectionPath('pong_leaderboard')), {
                    winnerId: winnerId,
                    loserId: loserId,
                    winnerScore: winnerScore,
                    loserScore: loserScore,
                    timestamp: serverTimestamp(),
                });
                console.log("Score recorded successfully.");
            } catch (error) {
                console.error("Error recording score:", error);
            }
        }

        function fetchLeaderboard() {
            if (!db || !isAuthReady || !userId) {
                console.warn("Auth not ready, skipping leaderboard fetch.");
                return;
            }

            const leaderboardRef = collection(db, getPublicCollectionPath('pong_leaderboard'));
            // Query without orderBy to prevent needing an index for every field combination
            const q = query(leaderboardRef); 

            if (unsubscribeLeaderboard) unsubscribeLeaderboard();

            unsubscribeLeaderboard = onSnapshot(q, (snapshot) => {
                const scoreMap = {};

                snapshot.forEach(doc => {
                    const score = doc.data();

                    // Aggregate wins/losses per user ID
                    scoreMap[score.winnerId] = scoreMap[score.winnerId] || { wins: 0, losses: 0, id: score.winnerId };
                    scoreMap[score.winnerId].wins++;

                    if (score.loserId) {
                         scoreMap[score.loserId] = scoreMap[score.loserId] || { wins: 0, losses: 0, id: score.loserId };
                         scoreMap[score.loserId].losses++;
                    }
                });

                let leaderboardData = Object.values(scoreMap);
                // Client-side sort to avoid Firestore index requirement
                leaderboardData.sort((a, b) => {
                    if (b.wins !== a.wins) {
                        return b.wins - a.wins; // Sort primarily by wins
                    }
                    return a.losses - b.losses; // Then by fewest losses
                });

                const body = document.getElementById('leaderboard-body');
                body.innerHTML = '';
                if (leaderboardData.length === 0) {
                    body.innerHTML = '<tr><td colspan="3" class="text-center text-retro opacity-50">No scores recorded yet.</td></tr>';
                    return;
                }

                leaderboardData.slice(0, 10).forEach((entry, index) => {
                    const row = body.insertRow();
                    const isCurrentUser = entry.id === userId;
                    const displayedId = entry.id.substring(0, 8);
                    
                    row.className = isCurrentUser ? 'bg-green-700/30' : '';

                    row.innerHTML = `
                        <td class="font-bold text-lg">${index + 1}.</td>
                        <td>${displayedId} ${isCurrentUser ? '(YOU)' : ''}</td>
                        <td>${entry.wins} - ${entry.losses}</td>
                    `;
                });
            }, (error) => {
                console.error("Error fetching leaderboard:", error);
                // Display error message in the leaderboard area
                document.getElementById('leaderboard-body').innerHTML = `
                    <tr><td colspan="3" class="text-center text-red-500">Error fetching leaderboard: ${error.message}</td></tr>
                `;
            });
            console.log("Leaderboard listener attached.");
        }


        // --- UI & INITIALIZATION ---

        function alertUser(message) {
            statusEl.textContent = message;
            statusEl.classList.remove('text-red-500', 'text-yellow-500', 'text-green-500');
            statusEl.classList.add('text-yellow-500');
            console.log("User Alert:", message);
        }

        document.getElementById('join-match-btn').addEventListener('click', claimPlayerSpot);
        document.getElementById('leave-match-btn').addEventListener('click', relinquishPlayerSpot);

        // Start the input loop and rendering loop
        setInterval(handleInput, 1000 / 60); // Check input 60 times per second
        
        window.onload = function() {
            renderGame();
            gameLoop();
            authenticateAndSetup(); // Start the authentication process
        };

    </script>
</body>
</html>
